﻿﻿
# ﻿﻿BinaryTree
----
- **重要函数**
```
void MakeTree(const T &x, BinaryTree<T> &ltree, BinaryTree<T> &rtree);   //合并左右子树
void BreakTree(T &x, BinaryTree<T> &ltree, BinaryTree<T> &rtree); //拆树
//递归遍历  封装 visit 为打印data的函数
void PreOrder_R(void(*Visit)(T &x))
void InOrder_R(void(*Visit)(T &x))
void PostOrder_R(Visit, root); printf("\n"); }
//非递归遍历
void PreOrder(void(*Visit)(T &x)); //使用栈
void InOrder(void(*Visit)(T &x));
void PostOrder(void(*Visit)(T &x)) ; 
void LevelOrder(void(*Visit)(T &x));//使用队列
void Gen_PreAIn(T Pre[],T In[],int len);  //根据先序遍历和中序遍历生成树
void Print_Parent(void(*Visit)(T &x), T Data) //打印结点的祖先结点
```
---
- **总结**
  - **模板类和模板函数必须放在.h文件中**：因为涉及程序是由编译,链接两部分完成的。编译的时候不同cpp是单独编译的。
  ![图片](https://github.com/jiexixijie/Have_Fun/blob/master/Res/BinaryTree_1.png?raw=true)
   假设实现过程存放在.cpp中在编译main.cpp时因为BinaryTree.h中只有函数名称没有实现过程，变成 jump[address]，  adders给链接器去填写，但是同样在编译BinaryTree.cpp时同样不知道模板中转换的类型是什么，因此也没有去编译，，也就可以看到虽然有这么多代码,但是生成的BinaryTree.o非常的小，因为这些函数在编译器看来根本没有被调用。最终在链接的时候因为在BinaryTree.o中根本没有对应函数的实现过程，所以就报错了。
  参考 : [C++的模板为什么要在头文件(.h)中实现？](https://mp.weixin.qq.com/s?__biz=MzA5MjQ2MDg1Mg==&mid=2247483716&idx=1&sn=b14ac：e510810e593c44c6439f610e770&chksm=906d831fa71a0a096d3079b6fac11a9659e9fd12db0fc0307ae30690542a2e30e8a456259298#rd) && [模板的声明和实现为何要放在头文件中？](http://www.cnblogs.com/wanyao/archive/2011/06/29/2093588.html)
  - **递归函数转非递归函数**：一般由堆栈帮忙。







